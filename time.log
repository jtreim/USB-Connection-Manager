DATE    START   END     TOTAL
03/08   14:50   15:50   1 hr

NOTES
Initialized repository.
Looking up how to remotely logon to windows machine, cause steam link
needs that.
https://www.tekrevue.com/tip/skip-windows-10-login-screen/ -> doesn't work remotely...
https://www.intowindows.com/how-to-automatically-login-in-windows-10/ -> default password?
https://stackoverflow.com/questions/48038678/how-to-programmatically-interact-with-winlogon
Raspberry pi remote desktop:
https://www.makeuseof.com/tag/rugged-raspberry-pi-projects-outdoors/
Allow it to create a restricted Windows user on the first time?
https://stackoverflow.com/questions/5984600/how-to-programmatically-create-windows-user-accounts-on-windows-7-or-windows-ser
https://stackoverflow.com/questions/3729406/create-local-user-account
I'd have to give it admin privileges for at least the first time though.
Still need to figure out how to give an application permission to turn on
the machine.
                        
https://www.ctrl.blog/entry/how-to-rdpwrapper-win10-home
I might not be able to remote desktop with my version of windows 10

My current thought is to create a restricted Windows user (somehow) that can only
allow steam link connections. Then if I can detect a wake-up signal from the
registered pi app, and recognize that it came from this app, the windows machine
automatically logs in to that restricted account. Of course, automating this setup
on both machines might be a bit of a pain.
The only other thing for all of this is to make a script that does all this when
the right USB connection is made.

---------------------------------------------------------------------------------------------------------------------------------------------------
DATE    START   END     TOTAL          
03/22   17:35   19:00   2 hr, 25 min

NOTES
Both a python option for sending WOL commands (just the wakeonlan library), and
a couple of bash commands (requires sed and netcat).

Bash command(s):
MAC=11:22:33:44:55:66
echo -e $(echo $(printf 'f%.0s' {1..12}; printf "$(echo $MAC | sed 's/://g')%.0s" {1..16}) | sed -e 's/../\\x&/g') | nc -w1 -u -b 255.255.255.255 4000

Sooo . . . port forwarding is messy from my apartment . . . I might need
the host on a different network. I need a router I have admin access to.

---------------------------------------------------------------------------------------------------------------------------------------------------
DATE    START   END     TOTAL
03/23   10:40   11:25   5 hr, 20 min
        11:50   12:30
        12:35   13:25
        14:55   15:35

NOTES
Looking into Kivy for GUI (near the top on Google). Create dependency file.

Kivy's kinda nice. Decided how I want to organize screens, widgets, and
general app structure. Shouldn't need to add much to the app, but if I wanted
to expand this to creating a platform that registers a command for USB
connections (or any connection, for that matter), this seems simple enough.

The current plan is to attach a bash script to all USB connections, which just
tells the machine to run my app. The app can then handle registering new
devices, or running commands as needed.

---------------------------------------------------------------------------------------------------------------------------------------------------
DATE    START   END     TOTAL
03/24   17:50   18:50   6 hr, 20 min

NOTES
Figured out backgrounds to these widgets. Kivy is conveniently hands-off on
almost everything, which is sometimes more convenient for them than it is for
me. Honestly, why they didn't include setting a background color is beyond me,
because I don't know of anyone at all that would argue against each widget being
able to define their own background color.

I might not bother with implementing a window resize. Yet another thing that
should be easier, but in the name of simplicity's sake, was not thought too
much about.

---------------------------------------------------------------------------------------------------------------------------------------------------
DATE    START   END     TOTAL
03/25   16:25   20:00   12 hr, 5 min
        21:50   00:00

NOTES
Played around a little more with how the register device window will look.

Looking at how to do something when a new USB device is plugged in.
Runs the attached script like 10 times...? For now I'll add a pidfile and check
to only run once.

Running a script on a USB connection to run the app immediately soft-killed the
machine (the screen went black for a little bit, all applications were closed,
I was logged out, and the screen was even oriented vertically when it came to).
Forgot to add "&& exit" after the command to start the script. udev hangs until
the script finishes.

Maybe I ought to switch to creating a python daemon and use the pyudev library.
I don't like having an application that is always on. Also, I need to be
careful about not creating an annoying pop-up window that no one wants.
Hopefully this will only be noticed on new USB connections, which shouldn't
happen too often.

Stack overflow suggests I can't create a window running a python script as
udev. Supposedly udev doesn't have permission.

Daemonizing isn't working. I can start up a sychronous process monitoring udev,
but I should figure out how to start this in the background. Preferably without
resorting to 'nohup' or '&'.

---------------------------------------------------------------------------------------------------------------------------------------------------
DATE    START   END     TOTAL
03/26   9:40    11:35   14 hrs

NOTES
I think the real issue with daemonizing is that the udev async monitoring isn't
staying alive long enough to mean anything.

Finally got the asynchronous stuff working. Daemonizing should hopefully be
not too much more work.

---------------------------------------------------------------------------------------------------------------------------------------------------
DATE    START   END     TOTAL
03/28   18:40   19:30   15 hrs 50 min
        21:30   22:30
NOTES
Turns out all I needed to do for WOL to work on the Windows host was turn off
fast startup. Also, I did find articles pointing out how allowing WOL is a
slight security issue; less so in a home environment, but still. This explains
why WOL is not natively enabled. It does make me wonder whether I'd like to
theoretically allow both WOL and a direct connection to my computer with port
forwarding or a VPN.

The pidfile package I'm using is only supported on Linux. So currently the app
itself can only run in Linux. Unless I want to develop a Windows version, that
is just how things are going to be.

I don't know why it isn't daemonizing...but everything else so far has been
pretty straightforward.

It's looking like there'll ultimately be 2 main scripts: one to add/remove
commands for devices, and one to determine how to interpret USB connections
and disconnections. I might need to create bit flags to be able to understand
all events that happen in between times the second script is actually awake.

---------------------------------------------------------------------------------------------------------------------------------------------------
DATE    START   END     TOTAL
04/02   19:30   21:00   17 hrs 20 min

NOTES
Set up a basic "db"--really just a json file that I read/write to. I tried to
write it so it wouldn't matter too much if I decided to write out a new dbtool
that involved an actual database structure.

Current error I'm getting:
WARNING:kivy:stderr: AttributeError: module 'daemon' has no attribute 'DaemonContext'

---------------------------------------------------------------------------------------------------------------------------------------------------
DATE    START   END     TOTAL
04/05   12:00   14:40   22 hrs 40 min
        17:40   18:20   
        19:30   21:30
NOTES
Don't name the daemon script the same thing as the module used within it.
That's what that error meant.

There's a really ugly world beneath identifying USB devices in udev. Not a
lot of consistency in attributes retrieved between usb port connections. And
several rapid-fire announcements to the system that something new just
connected. I have a rough way to identify different usb objects, but I'm
sure it is not foolproof.

Also worked on setting up some bit flags for adding or removing devices while
the daemon script does its thing. Prolly going to want to spawn a new app
process instead of hanging the script when it's time to register a new device.

As long as I have a usb device with my custom id registered, with a bash cmd to
do, I can run it. I just turned on my desktop computer by plugging in my usb
controller.

In order to pass in flags to the kivy app, I inserted another main script into
the process. I have to import kivy and everything about the app with a clean
sys.argv, or else kivy grabs flags that I don't want it to get.

The flow now looks like this:
When monitor.py starts up, it listens for any pyudev events. If an event occurs
it determines whether it needs to turn on the window or just run a command. If
it runs a command, it goes back to waiting for more pyudev events. If it needs
to turn on the app, it spawns a child process to run manager.py, and then goes
back to waiting for more events.

When manager.py starts up, it checks the command-line arguments it receives to
determine what to give to the app. Once it has parsed all the flags and their
values, it clears the sys.argv for the app. Then it initializes the app with
the flag values it got, and runs the app USBApp.py.

The USBApp.py displays what values it got from the manager. The plan is to have
it interact with either manager.py or the dbtool itself to register commands
for usb connections.


This is getting messy.

---------------------------------------------------------------------------------------------------------------------------------------------------
DATE    START   END     TOTAL


NOTES